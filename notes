Section on top-down vs bottom-up approaches.
  Buttom-up may lead to over-engineering overly-contstrained solution due to lack of overview.
  Thus trying to find the optimal general solution has a big risk of trying to reshape your problem to a good solution.
 
  Top-down may lead to under-engineering, leaving the tool useless for anything but the one purpose that sparked the development.

  An analogy for a good solution would be the servo steering found in most modern cars. It drastically lowers the amount of force
  required for turning the steering wheel, by letting a servo motor aid in turning the wheels in the direction indicated by the driver.
  It enables average strengthed driver to operate very large vehicles. Some, that would otherwise be impossible to steer by hand.
  This, however, removes the "feel" of the road-grip that some drivers prefer - so that would be the tradeoff here.
  Nevertheless, the solution is good because it does not get in the way, but merely passively aids the driver so he/she does not have
  to think about it.
  It also means that we now have an applicable abstraction level for controlling vehicle direction; the steering wheel - regardless of
  vehicle size. Implementation details hidden.
  Likewise, a good software tool should aid the user, and provide minimal abstruction (and hinder unintended destruction).

Resource pools.
  Tests require resources that should be auquired from pools. Pools are resource containers with a fixed discrete amount of resources in them, or in some cases,
  containers with infinite amount of resources in them.
  Either they should hide behind macros, or provide components for other resources.
