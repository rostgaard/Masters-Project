\documentclass[10pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Kim Rostgaard Christensen}
\title{Requirements as tests}
\subtitle{Automatic generation of tests from requirements}

\begin{document}
\maketitle
%\begin{abstract}
%The world of software is ridden with stories about failed projects, and almost everyone has his or her on story about a given software system, that did not solve the task, which it was designed to. This indicates; either a mismatch between requirements and solution, or simply errornous requirement specifications.
%\end{abstract}

\section*{Background}
Within software projects, documented requirements often become outdated and irrelevant over time as requirements are implemented and verified manually. For long-lived projects that continuously add features and component, dynamic maintenance of requirements -- for instance in the form of a wiki -- may make requirement maintenance more accessible.\\
If this is in done in a sufficiently structured way with references to the implementation, the cost of requirements maintenance maintenance can be made worthwhile by writing them as tests -- or focus on testability.\\\\
Sufficient structure in requirement formalization may enable tests to be generated directly from requirements fully automatically.

\subsection*{Project}
The project will use the requirements from an existing system as case study and formalize structure of these, so that test generation from these is possible.
in the process, the open question below will be dealt with;
\begin{itemize}
  \item How to relate to code so that test can generated
  \item How to structure requirements
  \item Identify general patterns and constraints in the structure
\end{itemize}

%In the software engineering field, a paradigm shift from waterfall-oriented development methods, towards more agile and iterative methods. However, the iterative approach still has a requirements phase, that may play an only minor role in the implementation phase, and focus shifts to \emph{how to make it work}, rather than \emph{what it should do}. Test-driven development handles this pragmatically by enforcing that tests are written before implementations. This provides a strong interface-driven black-box oriented methodology. It also provides a feedback channel for requirement changes.\\\\
%Taking test-driven development a step further, one may perceive the software system in its entirety as a large interface, and it's requirements as the tests. Use cases are textual descriptions of the functional requirements of the system, which are typically written in a semi-formal language, using only terms clearly defined within a domain model or glossary.\\
%Applying transformations to use cases derived from requirements, turning them into automated acceptance tests, could provide a more requirement-oriented development method, keeping the requirements in the loop during the entire development process.

%\section{Project}
%The approach motioned above is influenced by model driven development, formal methods
%\begin{itemize}
%  \item Identify generalizable traits of automated acceptance test generation from a case study focusing on the constraints/complexity reduction tradeoff.
%  \item Establish a process for identifying requirements, research and possibly create methods for formalizing them
%  \item Build a proof-of-concept tool for generating tests from use cases
  %\item Evaluate the value of the approach.
%\end{itemize}
%A growing numer of software systems are being moved to the cloud, which makes it a lot easier to make "rolling releases", rather than monolithic releases. %TODO More

%During the development of the OpenReception project, the team have applied a number of ah-hoc measures to 

\end{document}