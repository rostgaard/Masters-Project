
%TODO more on this story. Something that leads to the discovery of a structure and pattern of use cases and tests. ALSO IMPORTANT; Add general section on tests (background and exisiting solutions) - and how this solution wishes to improve it.

\chapter{Background}
%TODO review this section and make it fit with next one.
This chapter provides the historical background and motivation for the idea that eventually became the topic of this thesis. It also gives a brief overview of the design and implementation of the case study system used in this thesis.

.. provides a brief introduction to software testing, test-driven development and how these relate to, and differ from this project.

\section{Software testing}

\subsection{Test-driven development}
A development methodology that emerged around the millennium and have been looking very promising is test-driven development. I focuses on -- as the name would also implicate -- tests before anything else. The basic work-flow is to first write tests, then refactor the code base of the system under development until the test passes. Then, to make sure the refactored code does not break existing functionality, all the previously written tests must be run. This work-flow is illustrated in the flow chart shown in \ref{fig:test-driven-development-flow}.

\begin{figure}[!htbp]
\centering
\includegraphics[scale=0.6]{\imgdir test-driven-development-flow}
\caption{Basic work-flow of test-driven development.}
\label{fig:test-driven-development-flow}
\end{figure}

Some of the arguments for using test-driven development is that it enables continuous regression testing. It focuses strongly on building the object and components that are needed rather than the ones that are thought to be needed. And it also lowers the gap between component design, and feedback.\cite{george2003}. By feedback is meant developer feedback -- whether the component works or not.\\
Test-driven development, in its nature, encourages code to be written testable. If a test is written prior to the code, then -- obviously -- the code written will be testable, or it will not pass the tests that originated it. This often means better code reuse and smaller, more loosely coupled components. This is probably due to the fact that when you write tests, it is often the case that you repeat some actions over and over again.\\\\ %TODO maybe an example?
Ho will this differ from TDD? It uses the same philosophy of; tests firsts.

\subsection{Continuous integration}
Continuous integration is a methodology, that u

 that supplements

 to Test-driven development.


\section{Tests glossary}
%TODO Verify these.
In this section brief glossary from the test domain
\begin{description}
  \item[Test coverage:] The tests coverage is an indication of how many of the branches system is actually covered by the tests. So, a simple function with a single \emph{if-else} branch, that had a test that covered only the \emph{if} branch would have a coverage of 50\%. If there was also a test for the \emph{else} branch, the coverage would reach 100\%. Test coverage applies to every level of testing, from acceptance tests to unit tests.
  \item[Unit test:] Small component test
  \item[White-box test:] A white-box test treats the system as a transparent box where all the internals are known. From these known internals, tests can be written to take a specific code path within the component under test. Unit tests are an example of a white-box test, as it tests the known internals of the unit. In the case study system, white-box tests are used to verify API's and system functionality -- effectively testing multiple API's in a single test.
  \item[Black-box test:] Test system as unknown
  \item[Integration test:] Test system as deployed, stress-tests and others
  \item[Acceptance test:] Test system as it should work
\end{description}

\section{Case study system}
Back in the fall of 2011, a physicist, an electrical engineer a systems programmer, three entrepreneurs and a software engineering student founded a small business. I was created to solve one grave problem that the entrepreneurs had; their current software system was becoming a larger and larger annoyance to them due to lack of upgrades and existing bugs that was never going to be fixed. The latter was due to the fact that the company supporting it, went bankrupt. Thus, a plan was laid to re-engineer a system that would serve as a drop-in replacement for their current one -- only this time as an open source system, so that at least there was a possibility to hand over support contracts to other suppliers, avoided their previous vendor lock-in.\\\\
The three entrepreneurs were in the business of ``reception hosting''. About one year after, the first conceptual prototype emerged, and by the end of 2013, an alpha version of the product was ready to be tested and hardened for production use. However, due to the high level of asynchronism, and low level of explicit coordination -- which was by design -- regressions became an increasing problem. And when the requirements also started to change, a dire need for automated, and usage-oriented testing became evident.


\subsection{Problem domain glossary}
In this section brief glossary from the problem domain is provided to cover the basic terminology used in the use cases.
\begin{description}
  \item[Customer:] The person in the role of purchasing the software. Assumed to have little or no knowledge about formalism, modeling or programming.
  \item[Contact:] A person or group known to the system -- i.e. previously created with contact details such as phone numbers and email addresses.
  \item[Receptionist:] A user in the system able to handle incoming calls by forwarding them or taking a message.
  \item[Caller:] Anyone who dials a phone number handled by the system. They are not known by the system \textit{a priory}, but the system \textit{may} store previously entered data that serves as a cache.
  \item[PBX:] Private Branch Exchange. A local phone switchboard with built-in logic that determines the flow and destination of a phone call based on dial-plans. Common PBX's capabilities phone queues, Interactive Voice Response (IVR) menus and transfers to either local extension, or external extension. A PBX can be either a special-purpose hardware device, or a software implementation running on regular general-purpose PC hardware. These are referred to as hard- and soft-PBX's, respectively.
  \item[Dial-plan:] A decision system that decides what to with a call from a set of rules, such as ``if the time of day is after 17 o' clock, send to voice mail'', or ``if the callee extension is +45 1234 5678'', put the call straight trough to manager's extension''. The concrete syntax is, of course closer to a programming language, and largely dependent on which PBX is used.
% \item[Domain concept] are usually also present in the mapping, and are usually mapped directly to a class.
%Use case definition: An event that describes behaviors and it's written from a user's perspective.

\end{description}
This glossary is incomplete, with regards to the domain model, but should be sufficient background for interpreting the following use cases.\\\\

\section{Business model and existing system}
The customer -- the Danish business Responsum -- sells what is called a hosted reception service. Their primary customer segment are other businesses -- both large and small. They employ a number of receptionists that answer phone calls on behalf of these businesses. They perform receptionist tasks as though they were physically located on the premises of those businesses, and have access to a lot of employee data, such as employee information, phone numbers and calendars. This information is continuously maintained by a number of service agents, usually by transferring data between systems manually.\\\\
Throughout the last ten years, they have used a COTS\footnote{Commercial Off The Shelf} system for this task, that is now showing its age. The system handles phone call routing, call handling (playing greetings and Interactive Voice Response (IVR) menus), presents reception information, manages call routing plans and reception information.
\begin{figure}[!hbpt]
\centering
\includegraphics[width=0.8\textwidth]{\imgdir frontdesk-client-ui}
\caption{Screenshot of the receptionist frontend of the existing system}
\label{fig:frontdesk_screenshot}
\end{figure}
The system is proprietary and abandoned by the developers and is still affected by open bugs and issues. Furthermore, the customers of Responsum are expressing an increasing interest in integrating their own system with the Responsum's system. An example of an integration could be calendar synchronization to lower the manual workload of their service agents.

\section{Replacement system}
This section gives a short introduction to the system, its architecture and design and the development process that ultimately motivated the test approach, that is the topic of this thesis.\\\\
\begin{figure}[!hbpt]
\centering
\includegraphics[width=0.8\textwidth]{\imgdir openreception-client-ui}
\caption{Screenshot of the receptionist frontend of the replacement system}
\label{fig:openreception-client-ui}
\end{figure}OpenReception web-based software/telephony system. It is a system designed to enable receptionists to handle incoming calls, and provide then with the appropriate information so that they may divert or directly handle the calls. The system is designed with high availability in mind with many -- largely independent -- components that are loosely coupled. This limits the Domino-effect, where one faulty component can take down another for no other reason than the fact that they are partitioned together.\\ This component-oriented design has also helped the testing process, as it enabled individual components to be tested and verified independently of the others. A screenshot of the receptionist client of the replacement system can be seen in figure \ref{fig:openreception-client-ui}.

\section{Project scope}
The fundamental requirements for the system originates directly from the fact, that is is supposed to be a drop-in replacement of an existing system. It should therefore, as a bare minimum, mirror the features of the existing system.\\
However, the current system has been in production for over ten years and lessons-learned has taught the customer how the system should be improved. Another thing that had to be considered, was the fact that the current system had proven it's stability. Despite being far from perfect, it was certainly usable and provided the technical means for the customer to keep the gears of their business model oiled.

%TODO maybe add a list of requirements.
%TODO features broke all the time, when was the system done?, Jenkins was introduced ...
%Use cases are stored in a wiki.

\section{Chosen architecture}
Being that the existing system was considered stable, and critical infrastructure, the replacement system was designed with simplicity, and high fault resilience in mind. This means that we tried to provide fall-back mechanisms for most of the system rather than over-eagerly handle every potential fault. The component diagram in figure \ref{fig:component_diagram} shows the architecture, and also gives away some hints about which components are critical, and which are not. Basically, the most critical path is the one that originates from the ``Receptionist Client'' and ends in the ``SIP trunk'' component. These components are considered soft real-time components and are essential for an operation. Fallout of any of these components means direct financial loss for the customer. Fallout of any of the other components (except for SIP Phone, which is actually part of the critical path mentioned above) are tolerated in the design, and the stateless nature of REST (see section \ref{sec:rest}) enables us to maintain caches that can supply clients with the data they need for handling calls.

%Something about fault handling, and about not knowning the "failure space"

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{\imgdir component_diagram}
\caption{Component diagram}
\label{fig:component_diagram}
\end{figure}

\section{Implementation}
\todo[inline]{Add nice introduction here}
\subsection{Fault tolerance}
Fault tolerance is built into the system, by first decomposing the system into a lot of smaller parts, reduce the amount the amount of communication (in particular; two-way communication) needed for the system to function, at least partially.

\subsection{Stateless architecture}
\label{sec:rest}
We are, like many others contemporary developers, using REST \footnote{(\textbf{RE}presentational \textbf{S}tate \textbf{T}ransfer)}. It is a reasonably new, and non-standardized (by any comity) techonology for building Web-connected API's. It is a client/server protocol that bases itself upon some very simple principles that enables high scalabilty by it's stateless design, This stateless design enables API providers to partition and cache their resources better, as they do not need to synchronize across partitions.\\
Automated system testing is also simplified quite a bit, when you don't need to take into account a protocol state.

\subsection{Loose coupling of components} 
In order to minimize the damage of a component failing, we have further atomized the REST API's that we created into smaller services, each responsible for only handling one single task. This is what is, informally, defined as the ``bulkhead pattern''. Originating from naval vessel floating compartments, that was composed of several individual bulkheads. These bulkheads could then be closed off, in case of a leakage in one of them. A parallel to software engineering is to divide your application into separate operating system processes that can be terminated if they start to leak memory, consume excessive amounts of CPU time, or merely lock up. Sometimes, killing worker processes is used as a preemptive method of assuring that processes are kept under control. The Apache HTTPD web server uses this strategy by maximizing the number of requests\footnote{http://httpd.apache.org/docs/2.2/mod/worker.html} a worker process may serve before being terminated and replaced.\\
In our architecture, we have divided the database operations, dialplan generation, CDR\footnote{Call Detail Records: records of call duration and other information used for invoicing} into dedicated servers, that may be replaced -- even while in production.

\subsection{Reactive application}
\label{ssec:server_notifications}
As an extension of the the stateless client/server architecture, a server notification-push pattern has also been added. This enables us make the user interface reactively update to global state changes, rather than having to poll for these changes periodically. It was the optimal way we could get the client interface to respond to system events in real-time. It ultimately also became an important component in testing, as we could use it as a mean to validate causal relationship of actions and events (for instance; a hangup action on a phone would lead to a hangup event notification).\todo{. maybe add a reference to the causality section}

\section{Testing strategy}
\label{sec:test}
During the progression of the project, it became more and more clear to us that we were constrained by two parameters, in regards to testing:
\begin{itemize}
  \item We needed to verify the the functionality of system as a whole, and argue that it was free of instabilities. This functionality was defined in the use cases.
  \item We had very limited man-hours available and, thus, had to prioritize very aggressively on what level to tests on.
\end{itemize}
\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{\imgdir receptionist_workflow}
\caption{Labeled activity diagram of the basic workflow of a receptionist}
\label{fig:receptionist_workflow}
\end{figure}
Being that the system consisted of a number of loosely coupled components, some of them not under our control, we decided to focus on writing up black-box tests focusing on verifying the behavior of the individual components, or multiple connected components.
Furthermore, we wanted to automate this using a continuous integration service that could run our tests for us, and provide us with reports on regressions, or identified bugs. But first, a proper level of testing had to be chosen.

\subsection{Level of testing}
\label{ssec:level-of-testing}
We chose path of assuming everything worked and, thus,  built tests from the perspective of how it should work. So we basically treated the system as a block-box system and abstract away as many implementation details as possible. For this purpose, we and built a ``robot-receptionist'' and a ``robot-caller''. These ``robots'' acted as clients and connected to the \textbf{REST-Data}, \textbf{REST-Call}, \textbf{REST-SIP} interfaces from figure \ref{fig:component_diagram}.\\\\

\subsection{Coverage of testing}
In order to test the system, using the black-box method, we needed to formulate the tests in a way that provided the broadest coverage possible. To achieve this, we crafted a set of activity diagrams from the use cases of the system (see figure \ref{fig:receptionist_workflow}). From this, we could assert that every ``happy path'' use case was covered, by covering every path of the activity diagram.

\subsection{Generation of tests}
To make sure that all paths were covered, every activity node got labeled. Any unique path through the activity diagram should then correspond to a use case, but more importantly; be realized by a test. To achieve this, we constructed a set of tools that, among other things contained the ``robots'' discussed briefly in section \ref{ssec:level-of-testing}.

\todo{.\\ This listing should probably be moved to a later chapter.}
\begin{lstlisting}[language=Python, caption=Example of a generated test, label=fig:python_test]

# Inherit Test_Case class from forward_call generalization.
from forward_call import Test_Case

class Sequence_Diagram (Test_Case):
  def test_Run (self):
    try:
      Incoming_Call_ID = self.Request_Customer_Call ()
      Outgoing_Call_ID = self.Receptionist_Places_Call 
                               (Number = self.Callee.extension)
      self.Callee_Receives_Call ()
      self.Receptionist_Hears_Dialtone ()
      self.Callee_Accepts_Call ()
      self.Receptionist_Hangs_Up (Call_ID = Outgoing_Call_ID)
      self.Callee_Receives_Hang_Up()
      self.Teardown ()
    except:
      self.Teardown () # Cleanup processes started
      raise            # Re-raise exception so that 
                       # test fails after we cleaned up
\end{lstlisting}

\todo[inline]{Mostly notes and stubs from hereon}.

\section{Testing}

\subsubsection{Acceptance testing}
%TODO: STUB, explain CI beforehand.
An example of a generated sequence diagram is shown in figure \ref{fig:sequence_diagram_example}.
\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{\imgdir sequence_diagram_example}
\caption{Eksempel på sekvensdiagram}
\label{fig:sequence_diagram_example}
\end{figure}
By letting Jenkins CI automatically re-deploy the software stack and, run our acceptance test (along with a number of integration tests) every time the is any change to the code base, we both strengthen the confidence of the correctness (according to specification) of the software stack, and verify that no regressions arise. The continuous integration server can be reached at \url{http://ci.bitstack.dk/}


\subsection{Causality and tests}
\todo[inline]{stub section}
Defining for the tests system what valid transitions are, by creating state machines, and then store object state transitions, we can substantiate that no objects within the system will break causality -- at least in the situations elaborated in the use cases.

\subsection{Tools}
\todo[inline]{stub section, PJSUA-wrapper, PhonIO, libESL}


\subsubsection{UI testing}
\todo[inline]{Put to further work}
It is planned to expand the testing with use case playback from the user interface. A basic framework has been built using the Selenium project\footnote{http://www.seleniumhq.org/}.

\subsection{Revisioning}
\todo[inline]{This may belong somewhere else.}
\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{\imgdir git_branching}
\caption{Development model}
\label{fig:git_branching}
\end{figure}

%TODO Note:
%Motivation for chosen methodoligy
%  Buttom-up may lead to over-engineering overly-contstrained solution due to lack of overview.
%  Thus trying to find the optimal general solution has a big risk of trying to reshape your problem to a good solution.
%  Top-down may lead to under-engineering, leaving the tool useless for anything but the one purpose that sparked the development.

%TODO Aim/analogy for a useful tool
%  An analogy for a good solution would be the servo steering found in most modern cars. It drastically lowers the amount of force
%  required for turning the steering wheel, by letting a servo motor aid in turning the wheels in the direction indicated by the driver.
%  It enables average strengthed driver to operate very large vehicles. Some, that would otherwise be impossible to steer by hand.
%  This, however, removes the "feel" of the road-grip that some drivers prefer - so that would be the tradeoff here.
%  Nevertheless, the solution is good because it does not get in the way, but merely passively aids the driver so he/she does not have  to think about it.
%  It also means that we now have an applicable abstraction level for controlling vehicle direction; the steering wheel - regardless of   vehicle size. Implementation details hidden.
%Likewise, a good software tool should aid the user, and provide minimal abstruction (and hinder unintended destruction)