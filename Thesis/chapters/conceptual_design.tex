\chapter{Conceptual design}
\label{chap:conceptual_design}
This chapter is contains a discussion on the design of the different aspects of the requirement-to-test methodology. The discussion is started by defining an appropriate view on use case and then presenting three conceptual solutions along with a discussion on their applicability in the problem domain.\\\\
The goal is identify a suitable concept for a tool that enables us to inject better domain-awareness in our tests, and supports tests generation from them.
The concept should be designed to support loose structure, but still provide enough information test generation and basic requirement analysis.
% The constraint for not going after the optimum is added meta-model complexity.\\\\
\begin{figure}[!htbp]
\centering

\begin{tikzpicture}

% horizontal axis
\draw[->] (0,0) -- (6,0) node[anchor=north,midway] {\small Automation};

% vertical axis
\draw[->] (0,0) -- (0,4) node[anchor=south,rotate=90,midway] {\small Domain-awareness};

\draw (5,0.2) node[circle,fill,inner sep=1pt, fill=blue, label=above:1st iteration] {};

\draw (1.2,3.0) node[circle,fill,inner sep=1pt, fill=blue, label=above:2nd iteration] {};

% Project
\draw (5,3) node[circle,fill,inner sep=1pt, fill=dkgreen, minimum size=0.3cm, label=above:Project] {}; 

\end{tikzpicture}
\caption{Finding a good trade-off between domain-awareness and automation}
\label{fig:project_parameter_plot_project}
\end{figure}By discussing a iterating through a number of different conceptual designs, levering their benefits and disadvantages, a suitable model will hopefully emerge.

\section{Interpreting use cases}
While formalized use case models exist\cite{klimek2010formal}, they mostly focus on model checking and semantics. While this is indeed in important field of study, our scope is a bit different. As the tool we want to build here is meant as a support for existing development procedure -- rather than replacing it, and introducing formalism -- we constrain ourselves from constructing it from a formal model.\\\\
Instead we focus on the minimal structure, and build our way up from there. But, before we try to build up a model for use case that support test translation, we need to establish a common ground of what a use case is, what it should include, and what it shouldn't include. From \cite{cockburn2000} we get;
\begin{quote}
``... The use case, as the contract for behavior, captures \emph{all and only} the behaviors related to satisfy the stakeholdersâ€™ interests.''
\end{quote}which basically means that we should write our use cases, solely focusing on behavior and intent of the involved stakeholders. Any non-essential information should be left out. Another point that is commonly stated is that use cases should not be used to describe user interface actions, so for example an action ``user presses submit button'' is not suitable writing level for a use case.\\\\
So, in essence; use cases expresses \emph{expected system behavior from a stakeholder's point of view}. For this thesis we use the ``fully dressed'' use case template\cite{larman2005}, as it already provides very good structure to build upon. It specifies the need to include a stakeholder list, a primary actor, main scenario, pre- and postconditions and a list of extension that are linked to main scenario. An overview of the terms used for the remainder of the thesis is shown below.
\begin{description}
  \item[Use case:] The use case as a whole. Contains -- as a minimum -- a primary actor, which signifies to aspect of the use case, and a scenario. The use case represents a high-level goal that the primary actor wants to achieve.
  \item[Scenario:] The scenario is the list of steps (entries) that the primary actor needs to go through in order achieve the use case goal.
  \item[Entries:] Every step in the main scenario is composed of a entry. The entry may be decomposed into smaller components or just be a text, based on which level of detail we want. 
  \item[Extensions:] Extensions are alternate scenarios that branch out of the original scenario. 
  \item[Preconditions:] A list of predicates that needs to be true for the first step in the use case to be accessible.
  \item[Postconditions:] A list of predicates that needs to be true in order to make use case goal succeed, after the steps in the scenario (possibly including the extensions), have been performed.
  \item[Actors:] May be considered primary or supporting, as is typically a human performing a role in the system, but may also be another system that provides provides a service or information. An actor has a set of goals, which he/she wants to realize through the system. A good goal has a verb/noun combination, which is a good rule of thumb. when writing.
  \item[Concepts:] Concepts are general terms that are usually part of the meta model for the system under development. Basically, most terms that can be interacted with in the system under development count as concept. In our example system, a ``call'' is considered a concept.
\end{description}
This use case representation is used in the next section, where three use case editor concepts are presented.
\input{chapters/design_concept1}
\input{chapters/design_concept2}
\input{chapters/design_concept3}

\section{Additional concepts}
Given the loose structure of the use case concept, we believe it is sufficient to treat preconditions as simply other use cases. A more elaborate motivation for this can be found in section \ref{sec:test_case_state}.\\\\
Postconditions can be defined to be predicates

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{\imgdir event-stack-to-state-machine}
\caption{Concept; validate event stack using life-cycle state machines.}
\label{fig:event-stack-to-state-machine}
\end{figure}
%\section{Object tracking} NOTE: Maybe something about object lifecycles (and statemachines for them) here.

\begin{figure}[ht]
\centering
\begin{drawstack}
  % Within the environment, draw stack elements with \cell{...}
  \cell{lock}
  \cell{unlock}
\end{drawstack}
\caption{Event stack}
\label{fig:event-stack-example}
\end{figure}

Some basics on the procedure; take every line of the use case and not every concept and actor used. Then speculate on the realization of this. Which components should be involved, and which other actors. Depending on the concrete architecture, these components may be services, larger program components (such as Java packages), or even sub-functions.



%TODO Overall generation concept. A test needs to be supplied with some resources as input.