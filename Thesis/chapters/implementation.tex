\chapter{Implementation}
This chapter describe the tool that was implemented as part of this thesis, to enable the generation of tests from use cases. The chapter provides a high-level architectural view of the test system, and an example on how a use case goes from description to test.\medskip
As already mentioned in chapter \ref{ch:design}, the actions of users were eventually dropped, as they provided little or no value in test. This will become more evident, when an example of a generated test is shown.

\section{Architecture}
The implementation is done in a client/server architecture. It consists of a three basic components; a client, a service and a shared library. These map to the folder structure. It is web based to allow easy collaboration.\medskip
\begin{figure}[!htbp]
  \centering
  \includegraphics[scale=0.7]{\imgdir layered-mvc}
  \caption{Layered model-view-control architecture with test backend}
  \label{fig:layered-mvc}
\end{figure}
\noindent The distributed model is built around a layered model-view-control (MVC), that uses a dedicated test backend. Our backend built upon the Dart unittest library configured for junit xml output, the Jenkins continuous integration server, and Git revision control system. Git is used, first and foremost, to control revisions, but also as a test code distribution system. The Jenkins server will se a change in the Git repository, update to this version, and trigger a new build. Being that the tests output junit-format xml documents, Jenkins can parse this and provide detailed reports on success/failure output, run-times, and historical data.\medskip

\noindent The layered MVC introduced above, is a model commonly used in web programming. It is illustrated in figure \ref{fig:layered-mvc}, and is a method for maintaining the MVC paradigm, in a distributed system. In it's simplicity, it has a service interface that provide an API. This API delegates to an internal controller, that is allowed to modify the model. This model is only stored on by the service, but may be retrieved (or even pushed) to a client's model via a representation, which then becomes the service's view. The client's model is pushed to a local view, which is a user interface, that may send change requests to its local controller that delegates it to the controller of the service.\medskip

\noindent The client and the server share their code-base around a library package that contain (meta model) models, serialization/de-serialization tools, and the (use case) translation tools. The translation can, thus be done either by the client, or the server.

\section{Use case translation}
This section contains the a description of the different implemented components needed to support the use case to test translation.

\subsection{Test templates}
Test templates are, in this thesis, hand-written source code files that are missing the actual test code function bodies. They provide the tests with the implemented functions of what they need. So if a test makes a function call to a function called ``receptionist\_answers\_call(receptionist, call)'' with the passed parameters ``receptionist'' and ``call'', then the template is expected to provide this function.\medskip

\noindent The templates are quite simple. They are source code files that have a single placeholder entry that is replaced with the generated code by the tool. The placeholder is located within a comment, so template files can still be parsed and complied before the generation step, enabling them to be verified prior to use.\medskip
The templates are the mapping link between use case and the system under development, and are -- for the example use in this chapter -- linked to our case study system (section \ref{sec:case-study-system}.

\subsection{Actor classes}
%TODO Overall generation concept. A test needs to be supplied with some resources as input.
%lead-in
%TODO Umet conditions (pre- and postconditions) should be handled by writing a code block that throws an error. Could simply be an expect.

\subsection{Normalization of roles and steps}
%identities of objects.
%Concept 2 remainders are left in the source three, and my be studied for reference.
%TODO The actions proved no actual value without the mapping language, and was removed from the implementation.

\section{Example translation}
This section goes through the steps associated with creating tests from use cases in this implementation. The example is done, disregarding the concrete user interface details, which can instead be found in the handbook in appendix \ref{appendix:handbook}

\begin{lstlisting}[frame=single,style=usecase, caption=Use case example revisited, label=lst:uc-simple-example-revisited]
Scenario:
  Receptionist types in message
  Receptionist sends message
  Receptionist marks state as ready 
Preconditions:
  The receptionist is created
  The receptionist is logged in
Postconditions:
  The message is stored
  The receptionist is ready to handle the next call
\end{lstlisting}
%TODO verify that we have dropped the "action" concept in design concept 3.

\begin{lstlisting}[frame=single,style=usecase, caption=Use case example with its different parts highlighted, label=lst:uc-simple-example-highlighted-revisited]
Scenario:
  @\color{orange} Receptionist@ types in @\color{blue}{message}@
  @\color{orange} Receptionist@ sends @\color{blue}message@
  @\color{orange} Receptionist@ marks state as ready
Preconditions:
  The @\color{orange}receptionist@ is created
  The @\color{orange}receptionist@ is logged in
Postconditions:
  The @\color{blue}message@ is stored
  The @\color{orange}receptionist@ is ready to handle the next call
\end{lstlisting} 

\begin{lstlisting}[style=Dart, caption=Example of generated code without a template applied concept,label={lst:generated-test-code-example}]

void preconditions(Receptionist receptionist) {
  the_receptionist_is_created(receptionist);
  the_receptionist_is_logged_in(receptionist);
}

void postconditions(Receptionist receptionist, Message message) {
  the_message_is_stored(message);
  the_receptionist_is_ready_to_handle_the_next_call(receptionist);
}

void scenario(Receptionist receptionist, Message message) {
  preconditions(receptionist, message);
  receptionist_types_in_message(receptionist, message);
  receptionist_sends_message(receptionist, message);
  receptionist_marks_state_as_ready (receptionist)  
  postconditions(receptionist, message);
}

\end{lstlisting}


\begin{lstlisting}[style=Dart, caption=Example template methods (written manually),label={lst:example-template-methods}]
UserService userService = new UserService(...);
MessageService messageService = new MessageService(...);
DummyMessageFactory messageFactory = new DummyMessageFactory(...);
  
void the_receptionist_is_created(Receptionist receptionist) {
  try (userService.get(receptionist.user.id) {}
  catch (NotFoundException e) {
    throw new AssertionFailure("Receptionist " + 
                                receptionist + 
                               " not created");
  }
}

/* Later steps will fail if the receptionist is not logged in. */
void the_receptionist_is_logged_in(receptionist) {
   assume("the_receptionist_is_logged_in");
}

void the_message_is_stored(Message message) {
  Message fetchedMessage = messagService.get(message.id);
  expect (fetchedMessage, equals (message));
}

void the_receptionist_is_ready_to_handle_the_next_call(Receptionist r) {
  expect (r.state, equals(ReceptionistState.Idle);
}

void postconditions(Receptionist receptionist, Message message) {
  the_message_is_stored(message)
  the_receptionist_is_ready_to_handle_the_next_call(receptionist);
}

void receptionist_types_in_message(Receptionist r, Message message) {
  // Generate() takes a Receptionist parameter - signifies author.
  message = messageFactory.generate(r);
}

void receptionist_sends_message(receptionist, message) {
  messageService.send(message);
}

void receptionist_marks_state_as_ready(receptionist) {
  userService.changeState(receptionist.user);
} 
\end{lstlisting}

\section{Writing mapper function}
Some basics on the procedure; take every line of the use case and not every concept and actor used. Then speculate on the realization of this. Which components should be involved, and which other actors. Depending on the concrete architecture, these components may be services, larger program components (such as Java packages), or even sub-functions.
%TODO Describe the normalize function.
%TODO Describe the technique as well. (The Mapping process).


%TODO mention why mapping actions are no longer relevant.
\subsection{Running the analysis}
Having a set of definitions, we can detect actors and concepts from textually analysing the text of every UseCaseEntry object. The analysis is quite simple, and merely looks for occurrences of the definition by comparing strings.

%\section{Test framework}
% You need to write a test framework containing object pools, factory classes aso.
%\subsection{Exploiting injected semantics}
%How may we benefit from additional semantics? We can identify rubbish postconditions, such as predicates that involve objects that are either not modified in the statements, or simply never referenced.

\section{Testing}
% A use case returns a outputstate which is composed by an outputlog (log messages). A list of assumptions or an error. An error is for when an expectation failed, or a system error occured. Assumptions are for use case entries that are mapped to assumption statements.

\section{Protocol}
On the interface side, we decided that 2xx series HTTP codes where mapped to normal responses, and 4xx and 5xx to execeptions. 1xx and 3xx series are unused in our stak, and thus, unmapped. But it provides us with a good tool for -- on the client -- to explicitly state which replies should go where, and how they should be handled. A complete protocol specification is shown in appendix \ref{appendix:protocol}.

\section{Initial state}
The initial state of the test support tools are provided by a global setup and teardown function that encapsulates the entire pool of tests.

\section{Summary}
The implementation is on a prototype stage and contains some open ends.

The use case-as-precondtions could be implemented via a carried environment.. (explained somewhat in design).
