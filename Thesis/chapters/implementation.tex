\chapter{Implementation}
%TODO The capabilties (actions) were eventually dropped, as they provided little or no value.
%TODO Umet conditions (pre- and postconditions) should be handled by writing a code block that throws an error. Could simply be an expect.
Some basics on the procedure; take every line of the use case and not every concept and actor used. Then speculate on the realization of this. Which components should be involved, and which other actors. Depending on the concrete architecture, these components may be services, larger program components (such as Java packages), or even sub-functions.
%TODO Describe the normalize function.
%TODO Describe the technique as well. (The Mapping process).
\section{Template}
The templates are quite simple. They are source code files that have a single placeholder entry that is replaced with the generated code by the tool.

The placeholder is contained within a comment, so template files can still be parsed and complied before the generation step.


%TODO Overall generation concept. A test needs to be supplied with some resources as input.
%lead-in
The implementation is done in a client/server architecture. It consists of a three basic components; a client, a service and a shared library. These map to the folder structure. It is web based to allow easy collaboration.
%\section{Current implementation}
% tcc-tool is a client/server architecture with a share library.


%TODO add MVC to glossary.
Everything is built up as a layered model-view-control (MVC), that share a common library of models, utilities and interfaces.
%TODO what does the layer mean?

%identities of objects.
%Concept 2 remainders are left in the source three, and my be studied for reference.
%TODO The actions proved no actual value without the mapping language, and was removed from the implementation.

\subsection{Client}

\section{Example translation}

%TODO enter the use case.

\begin{lstlisting}[frame=single,style=usecase, caption=Use case example revisited, label=lst:uc-simple-example-revisited]
Scenario:
  Receptionist types in message
  Receptionist sends message
  Receptionist marks state as ready 
Preconditions:
  The receptionist is created
  The receptionist is logged in
Postconditions:
  The message is stored
  The receptionist is ready to handle the next call
\end{lstlisting}
%TODO verify that we have dropped the "action" concept in design concept 3.

\begin{lstlisting}[frame=single,style=usecase, caption=Use case example with its different parts highlighted, label=lst:uc-simple-example-highlighted-revisited]
Scenario:
  @\color{orange} Receptionist@ types in @\color{blue}{message}@
  @\color{orange} Receptionist@ sends @\color{blue}message@
  @\color{orange} Receptionist@ marks state as ready
Preconditions:
  The @\color{orange}receptionist@ is created
  The @\color{orange}receptionist@ is logged in
Postconditions:
  The @\color{blue}message@ is stored
  The @\color{orange}receptionist@ is ready to handle the next call
\end{lstlisting} 

\begin{lstlisting}[style=Dart, caption=Example of generated code without a template applied concept,label={lst:generated-test-code-example}]

void preconditions(Receptionist receptionist) {
  the_receptionist_is_created(receptionist);
  the_receptionist_is_logged_in(receptionist);
}

void postconditions(Receptionist receptionist, Message message) {
  the_message_is_stored(message);
  the_receptionist_is_ready_to_handle_the_next_call(receptionist);
}

void scenario(Receptionist receptionist, Message message) {
  preconditions(receptionist, message);
  receptionist_types_in_message(receptionist, message);
  receptionist_sends_message(receptionist, message);
  receptionist_marks_state_as_ready (receptionist)  
  postconditions(receptionist, message);
}

\end{lstlisting}


\begin{lstlisting}[style=Dart, caption=Example template methods (written manually),label={lst:example-template-methods}]
UserService userService = new UserService(...);
MessageService messageService = new MessageService(...);
DummyMessageFactory messageFactory = new DummyMessageFactory(...);
  
void the_receptionist_is_created(Receptionist receptionist) {
  try (userService.get(receptionist.user.id) {}
  catch (NotFoundException e) {
    throw new AssertionFailure("Receptionist " + 
                                receptionist + 
                               " not created");
  }
}

/* Later steps will fail if the receptionist is not logged in. */
void the_receptionist_is_logged_in(receptionist) {
   assume("the_receptionist_is_logged_in");
}

void the_message_is_stored(Message message) {
  Message fetchedMessage = messagService.get(message.id);
  expect (fetchedMessage, equals (message));
}

void the_receptionist_is_ready_to_handle_the_next_call(Receptionist r) {
  expect (r.state, equals(ReceptionistState.Idle);
}

void postconditions(Receptionist receptionist, Message message) {
  the_message_is_stored(message)
  the_receptionist_is_ready_to_handle_the_next_call(receptionist);
}

void receptionist_types_in_message(Receptionist r, Message message) {
  // Generate() takes a Receptionist parameter - signifies author.
  message = messageFactory.generate(r);
}

void receptionist_sends_message(receptionist, message) {
  messageService.send(message);
}

void receptionist_marks_state_as_ready(receptionist) {
  userService.changeState(receptionist.user);
} 

\end{lstlisting}

\section{Testing}

\section{Summary}
The implementation is on a prototype stage and contains some open ends.

The use case-as-precondtions could be implemented via a carried environmen.. (explained somewhat in design).
