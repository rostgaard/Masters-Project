\chapter{Misfits}

\section{Event stack validation concept}
\label{appendix:event-stack-validation}
\subsection{Causality in tests}
%TODO review and merge with section below.
Defining for the tests system what valid transitions are, by creating state machines, and then store object state transitions, we can substantiate that no objects within the system will break causality -- at least in the situations elaborated in the use cases.

A concept that was coined in parallel with the three concepts above -- which is not exclusively related to use cases -- but more validation in general, is the stack-replay concept. It is neither implemented, nor designed further than this concept.
\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{\imgdir event-stack-to-state-machine}
\caption{Concept; validate event stack using life-cycle state machines.}
\label{fig:event-stack-to-state-machine}
\end{figure}
%\section{Object tracking} NOTE: Maybe something about object lifecycles (and statemachines for them) here.
Example; in the use case it is stated that a call is hung up and a callee awaits this event. The lifeline of the call is however not tracked and to be able to properly assert the true state of this, the code macro needs to into account this lifeline and reflect on which assertions hold for every stakeholder that has knowledge of the call. % TODO: Elaborate the example and explain that a phone call is a good example because it has an A and B-leg and potentially a system that tracks its state.

%was in conceptual design.

\section{Brainstorming}
Whenever there is a new use case, a change to an existing use case, or simply a definition, the system should try to generate tests from the new information. If this step fails it is likely due to insufficient concept mappings. From here, a software engineer must manually map individual definitions to system macro-functionality or, possibly the use case could be linked to an existing manually written test, if the generation step is not possible for some reason. A mockup of a user interface is shown in figure \ref{fig:use_case_editor_mockup}.

% Something about generating partially-automated tests, where the system sets up everything for the customer and then notifies them about the next steps they have to take to move the test forward.

%Was in concept 2

for now, we take a look at the ``Main success scenario'' and see that, broadly speaking, each use case action involves one actor performing an action, possibly affecting a target object -- which could be another actor. For the purpose of generating tests, it is not important that actors may target other actors though their actions, and this association is therefore left out of the meta model.\\\\
Postconditions are -- in this model -- defined to be predicates. This is because they share the common trait that they must be true, for the given expression to be true. In our case, the postcondition ``Receptionist is ready for next call'' states the actor receptionist that is participating in this use case, must be in a specific state when the last statement of the use case is done. A postcondition should refer to an actor, target or action previously defined in the use case to avoid redundant mapping. The predicate itself can be some sort of quantifiable strict logic such as ``Message has recipients'', or could as an extension be defined as the more loose ``Message should have recipients'', which should map to a warning in the generated tests, rather than an error.\\\
Within the definition mapping, the mapping class denotes the relation between either a predicate and a predicate expression, or a statement (indirectly by the actor, action, target composition). The mapping is uniquely defined by mapping by its composition of an actor, an action and a target, as it should be safe to assume that ``The contact accepts the call'' means the same no matter which use case it appears in. Each mapping will imply a requirement on a resource, which can be any actor or target. The are basically constraints stating the minimum functionality the test framework\footnote{Domain-specific scaffolding code that needs to be written by hand} should have to make the generated test code runnable. These resources could, in test code frameworks, be provided by factory classes or object pools.\\\\
Tests are the output of a sequence of mappings, that has a state which is then defined by the mappings that originally defined the test. The test will also have references to the predicate expressions that are outputted by mappings as well.

%From concept 2 section. Quite loose formulations.
Within a use case there are some bits of implicit knowledge that we need to extract. To begin with, we observe that for the use cases in appendix \ref{appendix:use-cases}, there are domain actors involved.

Each involved domain actor will then be mapped to a wrapper class that represents the domain object, and could possibly extend a class from the implemented code base.

In order to get the actor object to perform actions, we need to map the actions in the use case to some functions associated with the actor class. These functions could be a direct link to a method that is part of the main codebase which is tested against, a new method written specifically for this purpose - or a macro function that combines functionality from different domain concepts in a single functions.

Whenever there is a mention of an object (a target of an action) which could be, for instance, a message object we assume that its the same object that is tracked during the entire use case. So, from use case 2, we have ``Receptionist sends the message via the system'' in the main success scenario and ``Message is stored and ready for dispatching'' in the postconditions.

\subsection{Detecting logic errors in use cases}
When doing an
\begin{description}
  \item[Skipping actions may be prohibited:] Should it be possible to jump ahead in the use case?
  \item[Primary actor must participate:] The primary actor is important, as this is the stakeholder that defines the perspective and scope of the test. The primary is the person that starts the use case via an active action, or receives a start signal from another actor -- the system for instance. The primary actor must also be part of the main scenario, and an analysis error should occur if this is not the case.

\end{description}
\subsection{Capabilites of an actor}
If we were to add additional domain knowledge to the use cases, then we would also be able to extract capabilities easily.
%yada yada, use case example: actor does something to some other thing
% it means the the actor can do something to some other thing.

