Within software projects, documented requirements often become outdated and irrelevant over time as requirements are implemented and verified manually. For long-lived projects that continuously add features and components this problem is even greater, as maintenance of requirements while adding new ones significantly increases the risk of requirement documentation decay further.\\\\
Requirement maintenance is usually a time-consuming and tedious task with little -- immediately -- added value and implementation mapping is either non-existing or implemented by an ad-hoc notation system, such as comments that link to source code files or integration tests.\\
Good requirements usually maps nicely to integration tests (either manual or automatic), but maintenance is needed for both if requirements change. It would therefore be very desirable to formalize requirements so that changes propagate to tests automatically.\\\\
Formalizing requirements is not a new idea. Methods like Vienna Development Method do exactly this by textually modeling the system under design, and specifies mathematical semantics to use. This gives the great benefit of being able to verify model correctness and perform code (or code stub) generation.\\
These systems are rarely used in practice, as they are very rigid and hard to read to anyone not proficient in the notation. A typical customer for a new software product would not be able to read, and even more critically, verify accuracy of requirements. In every case, most software engineers prefer more formalism due to the fact that processes (such as documentation and model checking) can be better automated.\\\\
Customers, on the other hand, are usually interested in very high level usage of systems, communicated in a natural language; such as ``The system should continuously monitor user activity and create statistics for a manager''. A statement such as this contains a lot of implicit domain knowledge and give rise to additional questions that needs to be answered and documented.\\\\
So, in summary, the dynamics of a requirement gathering have two opposite sides; one wishes more formalism, and the other wants less. The big question is then; can we find a middle ground? A methodology that constrains the user enough to inject useful semantics and structure in requirements, while keeping as much of the natural language as possible.\\
If the requirements are formalized in a sufficiently structured way, and annotated with references to the implementation, we would be also able to automatically generate system tests from them. By generating these tests, we effectively provide a feedback channel from implementation to requirements, as these tests will serve as a link between requirements and implementation.

%STUB:
There exist already methods and tools that extend the formalization of requirements, but there seems to be a lack of motivation for applying them. This lack of motivation is found in multiple stakeholders; programmers and customers.

\subsection{Project}
%This is a Model Driven Engineering (MDE) technique.
The basic idea is that sufficient structure in requirement formalization may enable tests to be generated directly from requirements fully automatically. To facilitate this, it means that requirements should be written with a strong focus on testability, and try to avoid bad requirements. This, as a side effect, may increase the motivation for quantifying, constraining and refining requirements. As an example: \emph{Who} will perform this action, and how are the outcomes expected to be presented/received?\\\\
These questions should -- preferably -- be answered by the customer of the system, and mapped to actual functionality that may then be tested with regards to the behavior described in the requirements. So, in essence, the very basic use case; ``Administrator creates a new user'' with the postcondition ``The new user is created in the system'' should result in a test that, in some way, performs the ``add user'' action of the Administrator actor, and then verifies it against the postconditions. Ideally; with an appropriate level of detail provided in the use cases, and a grain of automated (and manual) mapping to domain concepts will enable automatic generation of acceptance tests. These can then be combined with a continuous integration service that runs the tests and reports results to developers.\\\\
The project will use the requirements from an existing system as a case study and formalize the structure of these, so that test generation from them is possible. During this process, we will investigate how to structure requirements so that we can generate tests directly from them and map implementation to requirements. Ideally, we want to identify general patterns and constraints in the structure/formalism introduced to our requirements in the case study, to be able to apply them to other projects. But in general, we will investigate to which extent this idea can be applied, and try to implement a translation tool that is able to translate a representation of a use cases into a tests case.

%Original project description.

%\section{Background}
%Within software projects, documented requirements often become outdated and irrelevant over time as requirements are implemented and verified manually. For long-lived projects that continuously add features and components, maintenance of requirements becomes increasingly cumbersome, and increases the risk of requirement documentation decay further. Dynamic documents -- for instance, an inter-linked web document written in wiki markup -- may make requirement maintenance more accessible. This applies to both humans, but especially also for computers that may extract valuable information about system requirements for use in system verification tests.\\\\
%Additionally, if the requirements are formalized in a sufficiently structured way, and annotated with references to the implementation, the cost of requirements maintenance may be made worthwhile by enabling us to automatically generate system tests from them.
%\subsection*{Project}
%The key idea is that sufficient structure in requirement formalization may enable tests to be generated directly from requirements fully automatically. To facilitate this, it means that requirements should be written with a strong focus on testability. This, as a side effect, may increase the motivation for quantifying, constraining and refining requirements. As an example: \emph{Who} will perform this action, and how are the outcomes expected to be presented/received?\\\\
%The project will use the requirements from an existing system as a case study and formalize the structure of these, so that test generation from them is possible. During this process, we will investigate how to structure requirements so that we can generate tests directly from them and map implementation to requirements. Ideally, we want to identify general patterns and constraints in the structure/formalism introduced to our requirements in the case study, to be able to apply them to other projects. But in general, we will investigate to which extent this idea can be applied.
%In the software engineering field, a paradigm shift from waterfall-oriented development methods, towards more agile and iterative methods. However, the iterative approach still has a requirements phase, that may play an only minor role in the implementation phase, and focus shifts to \emph{how to make it work}, rather than \emph{what it should do}. Test-driven development handles this pragmatically by enforcing that tests are written before implementations. This provides a strong interface-driven black-box oriented methodology. It also provides a feedback channel for requirement changes.\\\\
%Taking test-driven development a step further, one may perceive the software system in its entirety as a large interface, and it's requirements as the tests. Use cases are textual descriptions of the functional requirements of the system, which are typically written in a semi-formal language, using only terms clearly defined within a domain model or glossary.\\
%Applying transformations to use cases derived from requirements, turning them into automated acceptance tests, could provide a more requirement-oriented development method, keeping the requirements in the loop during the entire development process.

%\section{Project}
%The approach motioned above is influenced by model driven development, formal methods
%\begin{itemize}
%  \item Identify generalizable traits of automated acceptance test generation from a case study focusing on the constraints/complexity reduction tradeoff.
%  \item Establish a process for identifying requirements, research and possibly create methods for formalizing them
%  \item Build a proof-of-concept tool for generating tests from use cases
  %\item Evaluate the value of the approach.
%\end{itemize}
%A growing numer of software systems are being moved to the cloud, which makes it a lot easier to make "rolling releases", rather than monolithic releases. %TODO More

%During the development of the OpenReception project, the team have applied a number of ah-hoc measures to 
