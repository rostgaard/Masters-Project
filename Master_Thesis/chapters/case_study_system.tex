This project uses the open source project ``OpenReception'' as case study. The project aims to provide a drop-in replacement for an existing system, and therefore has relatively fixed requirements that are extracted from the workings of the existing system. The system is developed and released under an open source license and any implementation details are therefore public domain and not covered by any non-disclosure agreements. This section gives a short introduction to the system, its architecture and design and the development process that ultimately motivated the test approach, that is the topic of this thesis.\\\\
OpenReception web-based software/telephony system. It is a system designed to enable receptionists to handle incoming calls, and provide then with the appropriate information so that they may divert or directly handle the calls. The system is designed with high availability in mind with many -- largely independent -- components that are loosely coupled. This limits the Domino-effect, where one faulty component can take down another for no other reason than the fact that they are partitioned together.\\ This component-oriented design has also helped the testing process, as it enabled individual components to be tested and verified independently of the others.

\section{Project scope}
The fundamental requirements for the system originates directly from the fact, that is is supposed to be a drop-in replacement of an existing system. It should therefore, as a bare minimum, mirror the features of the existing system.\\
However, the current system has been in production for over ten years and lessons-learned has taught the customer how the system should be improved. Another thing that had to be considered, was the fact that the current system had proven it's stability. Despite being far from perfect, it was certainly usable and provided the technical means for the customer to keep the gears of their business model oiled.

%TODO maybe add a list of requirements.
%TODO features broke all the time, when was the system done?, Jenkins was introduced ...
%Use cases are stored in a wiki.

\section{Chosen architecture}
Being that the existing system was considered stable, and critical infrastructure, the replacement system was designed with simplicity, and high fault resilience in mind. This means that we tried to provide fall-back mechanisms for most of the system rather than over-eagerly handle every potential fault. The component diagram in figure \ref{fig:component_diagramt} shows the architecture, and also gives away some hints about which components are critical, and which are not. Basically, the most critical path is the one that originates from the ``Receptionist Client'' and ends in the ``SIP trunk'' component. These components are considered soft real-time components and are essential for an operation. Fallout of any of these components means direct financial loss for the customer. Fallout of any of the other components (except for SIP Phone, which is actually part of the critical path mentioned above) are tolerated in the design, and the stateless nature of REST (see section \ref{sec:rest}) enables us to maintain caches that can supply clients with the data they need for handling calls.

%Something about fault handling, and about not knowning the "failure space"

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{\imgdir component_diagram}
\caption{Component diagram}
\label{fig:component_diagramt}
\end{figure}

\section{Implementation}
\subsection{Fault tolerance}
Fault tolerance is built into the system, by first decomposing the system into a lot of smaller parts, reduce the amount the amount of communication (in particular; two-way communication) needed for the system to function, at least partially.

\subsection{Stateless architecture}
\label{sec:rest}
We are, like many others contemporary developers, using REST \footnote{(\textbf{RE}presentational \textbf{S}tate \textbf{T}ransfer)}. It is a reasonably new, and non-standardized (by any comity) techonology for building Web-connected API's. It is a client/server protocol that bases itself upon some very simple principles that enables high scalabilty by it's stateless design, This stateless design enables API providers to partition and cache their resources better, as they do not need to synchronize across partitions.\\
Automated system testing is also simplified quite a bit, when you don't need to take into account a protocol state.

\subsection{Loose coupling of components} 
In order to minimize the damage of a component failing, we have further atomized the REST API's that we created into smaller services, each responsible for only handling one single task. This is what is, informally, defined as the ``bulkhead pattern''. Originating from naval vessel floating compartments, that was composed of several individual bulkheads. These bulkheads could then be closed off, in case of a leakage in one of them. A parallel to software engineering is to divide your application into separate operating system processes that can be terminated if they start to leak memory, consume excessive amounts of CPU time, or merely lock up. Sometimes, killing worker processes is used as a preemptive method of assuring that processes are kept under control. The Apache HTTPD web server uses this strategy by maximizing the number of requests\footnote{http://httpd.apache.org/docs/2.2/mod/worker.html} a worker process may serve before being terminated and replaced.\\
In our architecture, we have divided the database operations, dialplan generation, CDR\footnote{Call Detail Records: records of call duration and other information used for invoicing} into dedicated servers, that may be replaced -- even while in production.

\subsection{Reactive application}
\label{ssec:server_notifications}
As an extension of the the stateless client/server architecture, a server notification-push pattern has also been added. This enables us make the user interface reactively update to global state changes, rather than having to poll for these changes periodically. It was the optimal way we could get the client interface to respond to system events in real-time.

\section{Testing strategy}
\label{sec:test}
During the progression of the project, it became more and more clear to us that we were constrained by two parameters, in regards to testing:
\begin{itemize}
  \item We needed to verify the the functionality of system as a whole, and argue that it was free of instabilities. This functionality was defined in the use cases.
  \item We had very limited man-hours available and, thus, had to prioritize very aggressively on what level to tests on.
\end{itemize}
\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{\imgdir receptionist_workflow}
\caption{Labeled activity diagram of the basic workflow of a receptionist}
\label{fig:receptionist_workflow}
\end{figure}
Being that the system consisted of a number of loosely coupled components, some of them not under our control, we decided to focus on writing up black-box tests focusing on verifying the behavior of the individual components, or multiple connected components.\\
Furthermore, we wanted to automate this using a continuous integration service that could run our tests for us, and provide us with reports on regressions, or identified bugs.\\\\
The basic premise was then to assume everything worked and build tests from the perspective of how it should work, and abstract away as many implementation details as possible. For this purpose, we and built a ``robot-receptionist'' and a ``robot-caller''. The activities identified in the use cases where turned into an activity diagram (see figure \ref{fig:receptionist_workflow}), which had every activity node labeled. Any unique path through the activity diagram should then correspond to a use case, but more importantly; be realized by a test.


\begin{lstlisting}[language=Python, caption=Example of a generated test, label=fig:python_test]

# Inherit Test_Case class from forward_call generalization.
from forward_call import Test_Case

class Sequence_Diagram (Test_Case):
  def test_Run (self):
    try:
      Incoming_Call_ID = self.Request_Customer_Call ()
      Outgoing_Call_ID = self.Receptionist_Places_Call (Number = self.Callee.extension)
      self.Callee_Receives_Call ()
      self.Receptionist_Hears_Dialtone ()
      self.Callee_Accepts_Call ()
      self.Receptionist_Hangs_Up (Call_ID = Outgoing_Call_ID)
      self.Callee_Receives_Hang_Up()
      self.Teardown ()
    except:
      self.Teardown () # Cleanup processes started
      raise            # Re-raise exception so that 
                       # test fails after we cleaned up
\end{lstlisting}

\section{Testing}

\subsubsection{Acceptance testing}
%TODO: STUB, explain CI beforehand.
An example of a generated sequence diagram is shown in figure \ref{fig:sequence_diagram_example}.
\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{\imgdir sequence_diagram_example}
\caption{Eksempel p√• sekvensdiagram}
\label{fig:sequence_diagram_example}
\end{figure}
By letting Jenkins CI automatically re-deploy the software stack and, run our acceptance test (along with a number of integration tests) every time the is any change to the code base, we both strengthen the confidence of the correctness (according to specification) of the software stack, and verify that no regressions arise. The continuous integration server can be reached at \url{http://ci.bitstack.dk/}


\subsection{Causality and tests}
%TODO stub
Defining for the tests system what valid transitions are, by creating state machines, and then store object state transitions, we can substantiate that no objects within the system will break causality -- at least in the situations elaborated in the use cases.

\subsection{Tools}
%TODO PJSUA-wrapper, PhonIO, libESL


\subsubsection{UI testing}
%TODO Put to further work.
It is planned to expand the testing with use case playback from the user interface. A basic framework has been built using the Selenium project\footnote{http://www.seleniumhq.org/}.

\subsection{Revisioning}
\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{\imgdir git_branching}
\caption{Development model}
\label{fig:git_branching}
\end{figure}





