\subsection{Evolution of software engineering}
The natural evolution of software engineering points towards increasing the level of abstraction, moving closer to the usage models that they try capture. Another benefit of using models is that they communicate much better than, for instance, source code. Whereas source code is usually filled with non-essential implementation-specific details, models aim only to capture the essence of what it represents. Models, lacking these details, are challenging to execute. An doing so requires a great deal of extra work, filling out the details with either code snibblets or equivalent constraints -- such as OCL.\footnote{Object Constraint Language - part of UML}\\\\
One problem with this approach is a that much technical knowledge is required to formulate the models, OCL constraints and/or snibblets required for the system to function. For most technical staff it feels like meta-programming that keeps them from doing real programming.
\\\\
Ideally, the person requesting the software being modeled (the customer), should do a lot of the modeling by him/herself. This, however, has historically proven itself infeasible as customers rarely know much about modeling or programming, and if they did, would probably not be requesting software but rather making it on their own.

% Stub - I don't know where it should go;
\subsection{Bad requirements}
In software engineering there is a rule of thumb saying that requirements should be testable. This probably originates from the more general rule that goals should be measurable, recognizing that a requirement is ultimately a goal and a test is a actually a measure. Having this in mind can prevent a fair amount of bad requirements.
% Something about the level of detailm the completeness and feedback loop. Prototyping an agile development.
%\section{Terminology}
%\subsection{Three kinds of models}
%This document will use three descriptions for models, which cover;
%\subsubsection{Informal models}
%Informal models are used to describe models whose primary purpose is serve as a communication or documentation tool, not have strict semantics and cannot be used for code generation or model-checking.
%\subsubsection{Formal models}
%Formal models, which can be used for verification -- such as Z or VDM or plain math. Anything that has strict semantics and can be used to unambiguously generate code.
%\subsubsection{Meta-models}
%Meta-models that model other models, such as UML.