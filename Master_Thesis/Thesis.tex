\documentclass[10pt]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{usecases}
\usepackage{lmodern}
\author{Kim Rostgaard Christensen}
\title{Requirements as tests}
\subtitle{Automatic generation of test from structured requirements}
%%%%********************************************************************
\usepackage{microtype}
%\usepackage{times}
\usepackage[utf8]{inputenc}     
\usepackage[english]{babel}
\usepackage{color}
\usepackage{xcolor}
\usepackage{lipsum}
\usepackage{hyperref}
%%%%********************************************************************
% fancy quotes
\definecolor{quotemark}{gray}{0.7}
\makeatletter
\def\fquote{%
    \@ifnextchar[{\fquote@i}{\fquote@i[]}%]
           }%
\def\fquote@i[#1]{%
    \def\tempa{#1}%
    \@ifnextchar[{\fquote@ii}{\fquote@ii[]}%]
                 }%
\def\fquote@ii[#1]{%
    \def\tempb{#1}%
    \@ifnextchar[{\fquote@iii}{\fquote@iii[]}%]
                      }%
\def\fquote@iii[#1]{%
    \def\tempc{#1}%
    \vspace{1em}%
    \noindent%
    \begin{list}{}{%
         \setlength{\leftmargin}{0.1\textwidth}%
         \setlength{\rightmargin}{0.1\textwidth}%
                  }%
         \item[]%
         \begin{picture}(0,0)%
         \put(-15,-5){\makebox(0,0){\scalebox{3}{\textcolor{quotemark}{``}}}}%
         \end{picture}%
         \begingroup\itshape}%
 %%%%********************************************************************
 \def\endfquote{%
 \endgroup\par%
 \makebox[0pt][l]{%
 \hspace{0.8\textwidth}%
 \begin{picture}(0,0)(0,0)%
 \put(15,15){\makebox(0,0){%
 \scalebox{3}{\color{quotemark}''}}}%
 \end{picture}}%
 \ifx\tempa\empty%
 \else%
    \ifx\tempc\empty%
       \hfill\rule{100pt}{0.5pt}\\\mbox{}\hfill\tempa,\ \emph{\tempb}%
   \else%
       \hfill\rule{100pt}{0.5pt}\\\mbox{}\hfill\tempa,\ \emph{\tempb},\ \tempc%
   \fi\fi\par%
   \vspace{0.5em}%
 \end{list}%
 }%
 \makeatother
 %%%%********************************************************************

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.4,0.4,0.4}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% Define colors used for listings
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
% Configuration for listings
\lstset{%
numbers=left,
frame=single,
numbers=left,
numberstyle=\tiny,
numbersep=15pt,tabsize=4,
flexiblecolumns=true,
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
basicstyle=\footnotesize\ttfamily,
stringstyle=\color{mauve},
numberstyle=\tiny\color{gray},
language=Java,
breaklines=true,
breakatwhitespace=true,
morekeywords={*,num,String,var,library,get,set} ,
}

\lstdefinestyle{usecase}{
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
  escapeinside={@}{@},
  keywordstyle=\bfseries,
  morekeywords = {Scenario, Postconditions, Preconditions}
}
\usepackage{drawstack}

\newcommand{\imgdir}{./img/} % Set the folder which contains the specific images for the report

%TODO
% Write up 3-4 use cases. How they relate to each other. Maps to concept, and work on a conceptual level.

%TODO Using expected object state lifecycles (ordered list of states) to describe verification conditions.

%TODO section om mappings and levels of mappings. From Crude (having _one_ ast that is _the_ use case downto full semantics in language). One ast is what was done initially in Coverage_Tests.
%NOTE : A brief section on collection of asynchronous responses (expectations) that come in arbitrary order.

\begin{document}
\maketitle
 
\tableofcontents
\newpage

\begin{fquote}[ -- Johann Wolfgang von Goethe][The Sorrows of Young Werthe][1774]Misunderstandings and neglect occasion more mischief in the world than even malice and wickedness. At all events, the two latter are of less frequent occurrence.
\end{fquote}
\begin{abstract}
The world of software is has over the years been tainted with stories about failed projects. Almost everyone has his or her on story about a given software system, that did not solve the task, which it was designed to. This indicates; either a mismatch between requirements and solution, or simply erroneous requirement specifications. In the last decades more emphasis have been put on the agile methods, where smaller time-boxed iterations intricately contains every development phase; design, implementation, documentation and validation. Requirement refinement and elicitation may, however, be left dead-in-the-water and remain a \emph{de facto} waterfall phase with neither feed-back from implementation and validation, nor feed-forward to validation.
\end{abstract}

\chapter{Introduction}
\input{introduction}

%\section{Acknowledgements}
%Tom Desair\footnote{http://www.tomdesair.com} for making his \LaTeX use case available for the general public, and especially this author who has benefited greatly from them.

\section{Glossary}
In this section brief glossary from the problem domain is provided to cover the basic terminology used in the use cases.
\begin{description}
  \item[Customer:] The person in the role of purchasing the software. Assumed to have little or no knowledge about formalism, modeling or programming.
  \item[Contact:] A person or group known to the system -- i.e. previously created with contact details such as phone numbers and email addresses.
  \item[Receptionist:] A user in the system able to handle incoming calls by forwarding them or taking a message.
  \item[Caller:] Anyone who dials a phone number handled by the system. They are not known by the system \textit{a priory}, but the system \textit{may} store previously entered data that serves as a cache.
  \item[PBX:] Private Branch Exchange. A local phone switchboard with built-in logic that determines the flow and destination of a phone call based on dial-plans. Common PBX's capabilities phone queues, Interactive Voice Response (IVR) menus and transfers to either local extension, or external extension. A PBX can be either a special-purpose hardware device, or a software implementation running on regular general-purpose PC hardware. These are referred to as hard- and soft-PBX's, respectively.
  \item[Dial-plan:] A decision system that decides what to with a call from a set of rules, such as ``if the time of day is after 17 o' clock, send to voice mail'', or ``if the callee extension is +45 1234 5678'', put the call straight trough to manager's extension''. The concrete syntax is, of course closer to a programming language, and largely dependent on which PBX is used.
\end{description}
This glossary is incomplete, with regards to the domain model, but should be sufficient background for interpreting the following use cases.

\chapter{Top-down}
\subsection{Evolution of software engineering}
The natural evolution of software engineering points towards increasing the level of abstraction, moving closer to the usage models that they try capture. Another benefit of using models is that they communicate much better than, for instance, source code. Whereas source code is usually filled with non-essential implementation-specific details, models aim only to capture the essence of what it represents. Models, lacking these details, are challenging to execute. An doing so requires a great deal of extra work, filling out the details with either code snibblets or equivalent constraints -- such as OCL.\footnote{Object Constraint Language - part of UML}\\\\
One problem with this approach is a that much technical knowledge is required to formulate the models, OCL constraints and/or snibblets required for the system to function. For most technical staff it feels like meta-programming that keeps them from doing real programming.
\\\\
Ideally, the person requesting the software being modeled (the customer), should do a lot of the modeling by him/herself. This, however, has historically proven itself infeasible as customers rarely know much about modeling or programming, and if they did, would probably not be requesting software but rather making it on their own.

% Stub - I don't know where it should go;
\subsection{Bad requirements}
In software engineering there is a rule of thumb saying that requirements should be testable. This probably originates from the more general rule that goals should be measurable, recognizing that a requirement is ultimately a goal and a test is a actually a measure. Having this in mind can prevent a fair amount of bad requirements.
% Something about the level of detailm the completeness and feedback loop. Prototyping an agile development.
%\section{Terminology}
%\subsection{Three kinds of models}
%This document will use three descriptions for models, which cover;
%\subsubsection{Informal models}
%Informal models are used to describe models whose primary purpose is serve as a communication or documentation tool, not have strict semantics and cannot be used for code generation or model-checking.
%\subsubsection{Formal models}
%Formal models, which can be used for verification -- such as Z or VDM or plain math. Anything that has strict semantics and can be used to unambiguously generate code.
%\subsubsection{Meta-models}
%Meta-models that model other models, such as UML.

\section{Background}
\input{background}

\section{First implementation}
The task felt ripe for automation. But first, we needed some sort of abstract representation of the use cases and thus the idea of use cases as tests were born.
\input{first_implementation}

%\section{The verification problem}
%TODO V-model.
\section{Second implementation}
During the evolution of the software, platform, language and architecture changes eventually landed us in a space where we had the opportunity to use the same programming language both on the sever and the client. We wanted to exploit this initially by sharing the model classes between the server and client, but it soon evolved into a larger framework, also covering interfaces and REST resource definitions. This section explains the processes of exploiting this framework for a third application; namely testing.
\input{second_implementation}


\section{Brainstorm}
\input{brainstorm}

\section{Proposed solution}
"Side-cart" tool that (maybe) uses natural language processing. The developement is supported by a two-sided approach. Both top-down and bottom-up. Meaning that design an implementation will go hand-in-hand and hopefully lead to a good middle-road.
%TODO something about existing approaches.
%TODO Step-wise go through the enhancement process.
%  - Basically, autogenerate the use case action code line
%  - Infer some Class dependencies, which then becomes Framework dependencies.
\input{manual_use_case_conversion}
\chapter{Case project}
\input{case_study_system}

\begin{figure}
  \centering
 
  \includegraphics[scale=0.2]{img/frontdesk-client-ui.png}
  \caption{Receptionist client user interface of existing system}
  \label{fig:frontdesk-client-ui}
\end{figure}

\begin{figure}
  \includegraphics[scale=0.2]{img/openreception-client-ui.png}
  \caption{Receptionist client user interface of OpenReception system}
  \label{fig:openreception-client-ui}
\end{figure}

\begin{figure}[h]
%\includegraphics[scale=0.4]{img/activity_diagram_receptionist}
\centering
\caption{Activity diagram for the receptionist actor}
\label{fig:activity_diagram_receptionist}
\end{figure}


%\section{Related work}
%\subsection{Writing requirements as tests}
%\subsection{Writing requirements in formal language}

\section{Brainstorming}
The problem in attaining broad coverage of use cases, and therefore completeness in requirements i primarily that, from the customer perspective, that they feel very overly-verbose and usually too formal in nature. For software engineers, the opposite is usually the case. They feel that the use case descriptions are not structured nor elaborate enough for use in, for instance, code stub generation.

More structure, however, could be helped along the way with proper tooling. Hiding some of the complexity of the constrains of a data model behind a simple user interface supplying dragable components and providing immediate visual feedback in the form of textual use case representation (or a diagram) could "cheat" the customer into adding the needed structure to the use case model.

\begin{figure}[h]
\includegraphics[scale=0.9]{img/use_case_creation_activity_diagram}
\centering
\caption{Use case creation with different actors}
\label{fig:use_case_creation_activity_diagram}
\end{figure}

What is in the customers interest is having acceptance tests match the use cases as closely as possible. Preferably, the should be able to be automated as well. Figure \ref{fig:use_case_creation_activity_diagram} shows an activity diagram involving three actors, the customer, the engineer and the system\footnote{Use case system}. In this diagram, the customer authors use cases while adding missing definitions not already in the tool. A definition is textual description of a concept which may be -- for instance -- an actor, role or action. This description is then given a unique name, that may correspond to a concept already found in the domain model. The domain model, if defined beforehand, could also be thought to be a part of the built-in declarations.

\begin{figure}[h]
\includegraphics[scale=0.9]{img/test_case_ui}
\centering
\caption{Use case editor UI mockup}
\label{fig:use_case_editor_mockup}
\end{figure}

Whenever there is a new use case, a change to an existing use case, or simply a definition, the system should try to generate tests from the new information. If this step fails it is likely due to insufficient concept mappings. From here, a software engineer must manually map individual definitions to system macro-functionality or, possibly the use case could be linked to an existing manually written test, if the generation step is not possible for some reason. A mockup of a user interface is shown in figure \ref{fig:use_case_editor_mockup}.

% Something about generating partially-automated tests, where the system sets up everything for the customer and then notifies them about the next steps they have to take to move the test forward.

\section{Extracting semantic}
Example; in the use case it is stated that a call is hung up and a callee awaits this event. The lifeline of the call is however not tracked and to be able to properly assert the true state of this, the code macro needs to into account this lifeline and reflect on which assertions hold for every stakeholder that has knowledge of the call. % TODO: Elaborate the example and explain that a phone call is a good example because it has an A and B-leg and potentially a system that tracks its state.

\subsection{Letting the customer inject semantics}

There are two basic approaches to letting the customer inject semantics into the requirements. The first is to do a full up-front declaration of every term used within the problem domain and supply this as a toolbox for the customer %todo example.
The other approach is to do it on the go by outlining concepts as stubs whenever they appear. This approach is similar to what is used in wiki software. %todo eaxmple

\section{Class-responsiblity-collaboration cards}
%Nouns should turn into the classes of the card, verbs typically turn into the responsibilities of the card, and collaborators are the other cards with which the card will be interacting with.
%FROM: http://en.wikipedia.org/wiki/Class-responsibility-collaboration_card

\section{Verification problem}
A big issue in software

\section{End-user experience}
%The challenge in documenting requirements is, and has always been, to formulate them on a non-ambiguous form. The quantification of ambiguity tends to be difficult as well, due to the fact that requirements are usually formulated in natural languages following some rules, such as pre-defined glossary and constraints. Constraints vocabulary typically consists of should, could, may, must.

%As requirements are basically constraints to your system, a subset of them may be expressed as expressions following a formality that is machine-interpretable. Vienna Development Method (VDM) and Z notation are two approaches that tries to formally describe systems on a very high level, so that model-checking can be performed on it prior to programming.

An example UI is Starting from scratch, the user would be expected to initially define at least one actor and add a sequence of actions that the actor perform.

%Other method
Wiki-collaboration to "lazily" define the problem domain and verification conditions along the way.

\section{Test setup}
%scaffolding and harness

\section{Formulating requirements}

\section{Framework discussion}
\subsection{Metrics}
% How many lines of code is the support tools? The middleware framework?
% How is it compared to the activity count in the activity diagram?
\subsection{Recommended test framework guidelines}
%Use allocation pools
%Use interfaces a objects.

\section{Requirements as communication platform}

Avoid technical jargon (\cite{christel1992issues})

\section{Related work}
\subsection{FIT Framework}

We've taken an offset in use cases, but there could be other ways of structuring the requirements of a system, such as the SCRUM user story format;
%Use the SCRUM approach. Don't describe a feature as
%"It should be doing this and that in the following way"
%While the sentence above describes all you need to know to implement the feature, it does not justify the feature. My SCRUM book says features should be written down as a story. A story looks like this:
%"As a <user-role>
%I need a <functionality>
%So that I get <business value>"
%A feature that cannot be justified using such a story is an unjustified feature and thus there is no use to actually implement it.
%E.g.
%"As a visitor of a web portal I need a way to authenticate, so I can access my customer data, but nobody else can"
%Now you don't only know that you need an authentication for your web portal, you also know who needs it (the visitors, basically everyone planing on using it more intensively) and you also know why it is needed, as it gives the user some value.
%Other examples:
%"As a passenger I need a list of all my booked journeys, so that I know when I'm going to travel where and won't lose the overview"
%"As a book keeper, I'd like to have the sales tax being automatically printed to each bill based on customer data, so that I don't have to enter it manually each time I'm printing a bill"
%If every feature needs to be written like that, you'll automatically see if a feature is for the customer, because it is really necessary, or just something your boss/company wants to have and also why they want to have it (what is the big picture behind it? Why are they doing it?).


\section{Use case writing level}
Should not be used to describe UI actions% http://alistair.cockburn.us/Use+cases%2c+ten+years+later (Use case limits).

Use cases expresses expected system behavior. Keep use cases free of UI-action.

There are several levels on which use cases can be written as per\cite{cockburn??}. In our case, it would make the most sense to use the "system" level, as business level is something that is nearly useless because it is largely out of scope. The business logic is also, more elaborately (and implicitly) formulated within a system-level use case. In the other end, a component use case is also very impractical, as our target audience would be people that does not know anything about the specifics of the system being built.

%Note;
An important aspect to keep in mind is that context is important. Writing hundreds of pages of detailed requirements are bound to be decoupled and lose context, and coherence with each other. Deciding on a level that keeps context is important.

\section{Expressing requirements}
%Requirement gathering and documentation often feels a lot like stating the obvious, and being overly-verbose.

\section{Use case translation}
\input{ast_use_case}

\section{Targeted requirements}
We've chosen to focus on the requirements that involves core features from the Receptionist actor point of view. These are, on a high level;
\begin{description}
  \item[Manage calls:] Being able to technically handle calls by performing receive, park, transfer and hangup action.
  \item[Process calls:] Being able to process calls in the context of a dialed reception. This involves having access to data about the reception and its contacts. Being able to dial them, or send them a message.
  \item[Manage message:] Being able to send out messages to contacts, view and resend existing messages.
\end{description}

For our targeted use cases, we've cherry-picked some specific paths from the activity diagram for the receptionist actor (see figure \ref{fig:activity_diagram_receptionist}).

\begin{description}
  \item[UC1: Transfer to contact:] A receptionist must be able to transfer a call to a chosen contact associated with the currently active reception. An example use case, from the receptionist actor point of view is outlined below.
  \begin{itemize}
    \item Preconditions.
    \begin{itemize}
      \item Receptionist is handling picked up incoming call $A$
      \item Receptionist has parked call $A$
    \end{itemize}
    \item Actions.
    \begin{itemize}
      \item Receptionist dials the number of the selected contact (call $B$)
      \item Receptionist hears dial tone
      \item The contact's phone is ringing.
      \item The contact accepts the calls (picks up)
      \item Receptionist has a dialogue with contact
      \item Receptionist transfers call $B$ to call $A$
      \item The system breaks the receptionist's connection to both call $A$ and $B$    
      \item Receptionist marks his/her state as idle.
    \end{itemize}
  \end{itemize}

  \item[UC2: Send message to contact:] A receptionist must be able to send a message -- via a distribution list -- to a contact, typically containing information received verbally via a call. An example use case, from the receptionist actor point of view is outlined below.
  \begin{itemize}
    \item Preconditions.
    \begin{itemize}
      \item Receptionist may have previously received a call $A$, which may still be active.
    \end{itemize}
    \item Actions.
    \begin{itemize}
      \item Receptionist finds contact $C$ who will serve as recipient
      \item Receptionist selects $C$
      \item Receptionist types in message
      \item Receptionist sends the message via the system
      \item Receptionist marks his/her state as idle.
    \end{itemize}
  \end{itemize}
\end{description}

%TODO High leve description (customer level)

\chapter{Validating implementation}
%Something about the V-model.

\section{Formalized approaches}
%2.1. Use case description
%A semiformal use case description is simply a natural
%language text structured using a text template which divides
%the text into logical parts. Even though there is no broadly
%accepted standard use case template, the existing templates
%are quite similar.
\section{Testing}
%Fixtures
%Design by contract
%Harness

\section{Regression testing}

\chapter{Requirement formalization}
Actors, Roles

Aspects. Behavior. State space.

\section{Use case as base}
%\includegraphics[scale=0.4]{img/req_meta.png}

\subsection{What to include?}
From \cite{Cockburn:2000:WEU:517669} we get;
\begin{quote}
``... The use case, as the contract for behavior, captures \emph{all and only} the behaviors related to satisfy the stakeholdersâ€™ interests.''
\end{quote}

\section{Processes}

\chapter{Test generation}
Using -- exclusively -- the use case from \textbf{RQ2} as base, we try to derive what is needed in order to generate a basic test.
To achieve the minimum implementation, we cut away the optional precondition that may be covered by other use cases. After this, we see an implicitly \emph{ordered list of actions} that we need to succeed in order for the test to be a success. There is an actor that performs an action at each step. The system, in its entirety, may also be referred to as an actor as it is also capable of performing actions.

So, summing up, we have;
\begin{itemize}
  \item This use case consists of an ordered list of actions, where actions consist of
  \begin{itemize}
	\item One or more actors
	\item One verb describing the action
	\item One target for the action (object for verb)
  \end{itemize}
\end{itemize}
If we 

\section{Requirement/test mapping}
%The communication model needs to be known.

We consider a use case to a flow events that mutates a state...


\section{Environment}
Traversing the use case is considered a long function call-chain. Each new procedure call passes along the current global state onto the next procedure. This method of passing along the state is a common pattern is interpreters and compilers, where the global state is referred to as "the environment". In our test-case compiler we adopt this approach. One of the large benefits is to have the ability to have an exit procedure that performs state clean upon exit of every use case. These procedures should run regardless of exceptions raised within the call-chain, but respond to them. This behavior is identical to the functionality seen in "teardown" functions in test framework for programming languages. See section \ref{sec:test_framework_programming} for a discussion on these frameworks.\\\\
The environment should contain the current state within the scope of test currently running. By state is meant any objects created or modified during the test.

\chapter{Process evaluation}

%\section{Applicablity to different methodologies} See http://en.wikipedia.org/wiki/Requirements_analysis
% Waterfall, Prototype model, Incremental, Iterative, V-Model, Spiral, Scrum, Cleanroom, RAD ...


% Further work
%  - Misuse case
%  - Validating event chain against a state machine (automaton).
\chapter{Conclusion}

\bibliographystyle{plain}
\bibliography{references}

\nocite{*}

\end{document}
